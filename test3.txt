#5
наследование - это механизм наследования новых классов из существующих. Наследование позволяет программистам создавать классы, основанные на существующих классах, и это позволяет классу, созданному посредством наследования, наследовать атрибуты и методы родительского класса. Это означает, что наследование поддерживает возможность повторного использования кода. Методы или, вообще говоря, программное обеспечение, унаследованное подклассом, считается повторно используемым в подклассе. Отношения объектов или классов посредством наследования порождают ориентированный граф.


#6
Инкапсуляция — ограничение доступа к составляющим объект компонентам (методам и переменным). Инкапсуляция делает некоторые из компонент доступными только внутри класса.
Модификаторы доступа в Python используются для модификации видимости переменных по умолчанию. 
Есть 3 типа модификаторов доступов:
публичный — public;
приватный — private;
защищенный — protected.
Доступ к переменным с модификаторами публичного доступа открыт из любой точки вне класса, доступ к приватным переменным открыт только внутри класса, и в случае с защищенными переменными, доступ открыт только внутри того же пакета.

#7
Полиморфизм - разное поведение одного и того же метода в разных классах. Например, мы можем сложить два числа, и можем сложить две строки. При этом получим разный результат, так как числа и строки являются разными классами. Это относится к использованию сущности одного типа (метода, оператора или объекта) для представления разных типов в разных сценариях.

#8
Абстракция - метод решения задачи, при котором объекты разного рода объединяются общим понятием (концепцией), а затем сгруппированные сущности рассматриваются как элементы единой категории. Например, люди не думают об автомобиле как о совокупности тысяч отдельных деталей. Вместо этого они видят в нем четко определенный объект со своим уникальным поведением. Эта абстракция позволяет людям управлять автомобилем, не зная о сложности деталей, из которых он состоит. Они могут игнорировать детали того, как работает трансмиссия двигателя и тормозные системы. Вместо этого они могут использовать объект в целом.
Мощный способ управления абстракцией - использование иерархической классификации. Это позволяет нам наслоить семантику сложных систем, разбивая их на более управляемые части. Снаружи автомобиль представляет собой единый объект. Оказавшись внутри, вы видите, что автомобиль состоит из нескольких подсистем: рулевого управления, тормозов, аудиосистемы, ремней безопасности и т. Д. В свою очередь, каждая из этих подсистем состоит из более мелких блоков.
 
#9
Композиция — это концепция, которая моделирует отношения. Она позволяет создавать сложные типы, комбинируя объекты других типов.

#10
Итераторы - это объект, который дает Python возможность итерации. Объект, который возвращает данные, возвращает по одному элементу за раз. Итераторы появляются в языке программирования Pyhton в таких точках, как циклы, список, трубка и генераторы.
Объект итераторов Python содержит два специальных метода __iter __ () и __next __ (). Если мы можем получить значение из этих методов, это показывает, что мы находимся в объекте со свойством итератора. Например, список, кортеж и строка имеют эту функцию.

#11
Генераторы также имеют функцию __next __ (), как итераторы, поэтому их можно повторять. Отличие генераторов от итераторов в том, что они выполняют ленивое вычисление. Когда вы хотите выполнить итерацию объекта, он готов к итерации с элементами списка, и вы начинаете обработку, вызывая эти элементы последовательно. Элементы, которые вы будете перебирать в своих руках в генераторах, еще не существуют, они создаются и представляются вам, когда вы вызываете следующий. Если вы спросите, что это будет для нас, если вам не нужны все элементы списка для вашей операции или вы не знаете, сколько использовать, вы можете напрасно создать весь список и использовать генератор вместо того, чтобы раздувать память, и вы можете предотвратить использование избыточной памяти, создавая элементы по мере необходимости / по вашему запросу.

#12
Метаклассы – это такие классы, экземпляры которых сами являются классами. Подобно тому, как «обычный» класс определяет поведение экземпляров класса, метакласс определяет и поведение классов, и поведение их экземпляров. Метапрограммирование в Python основано на новом особом типе классов, метаклассами. Этот тип класса, вкратце, содержит инструкции о закулисной генерации кода, который вы хотите получить, запуская другой код.

#13
Миксин - это особый вид множественного наследования. Существуют основные ситуации, в которых используются миксины:
Вы хотите предоставить много дополнительных функций для класса.
Вы хотите использовать одну особенность во множестве разных классов.
вы хотите предоставить много (не необязательных) функций для класса, но вы хотите, чтобы эти функции были в отдельных классах (и в отдельных модулях), чтобы каждый модуль имел одну функцию (поведение). для повторного использования, но для разделения.

#14
В Python классы создаются с помощью инструкции class, за которой следует произвольное имя класса, после которого ставится двоеточие, далее с новой строки и с отступом реализуется тело класса:

class ИмяКласса:
    код_тела_класса
    
Если класс является дочерним, то родительские классы перечисляются в круглых скобках после имени класса.
Объект создается путем вызова класса по его имени. При этом после имени класса обязательно ставятся скобки:

ИмяКласса()
То есть класс вызывается подобно функции. Однако в случае вызова класса происходит не выполнение его тела, как это происходило бы при вызове функции, а создается объект. Поскольку в программном коде важно не потерять ссылку на только что созданный объект, то обычно его связывают с переменной. Поэтому создание объекта чаще всего выглядит так:

имя_переменной = ИмяКласса()
В последствии к объекту обращаются через связанную с ним переменную.

Пример "пустого" класса и двух созданных на его основе объектов:

>>> class A:
...     pass
... 
>>> a = A()
>>> b = A()

#15
Мы можем видеть эту разницу, потому что при создании списка Python резервирует память для всего списка и вычисляет ее на месте. В случае генератора мы получаем только «алгоритм» / «инструкции», как рассчитать, что хранит Python. И каждый раз, когда мы вызываем генератор, он только «генерирует» следующий элемент последовательности по запросу в соответствии с «инструкциями». С другой стороны, генератор будет медленнее, так как каждый раз, когда элемент последовательности вычисляется и возвращается, контекст / состояние функции должны сохраняться, чтобы их можно было использовать в следующий раз для генерации следующего значения. Это «сохранение и загрузка контекста / состояния функции» требует времени.
